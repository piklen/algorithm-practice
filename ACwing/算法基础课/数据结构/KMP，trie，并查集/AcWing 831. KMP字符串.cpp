#include <iostream>
using namespace std;
int n, m, nx[100010];
char q[100010], s[1000010];
int main()
{
    cin >> n >> q + 1 >> m >> s + 1; //数组下标从1开始
    // next[]的求法
    for (int i = 2, j = 0; i <= n; i++) //第一个字符的next数组值为0
    {
        while (j && q[i] != q[j + 1]) //如果j没有回到最开端，也就是不为0，并且是后一个字符与当前主串字符不匹配，那么就不断找next数组
        {
            j = ne[j]; //一个递归的过程
        }
        if (q[i] == q[j + 1]) //如果是相等
        {
            j++; // j指针往后移动
        }
        nx[i] = j;
    }
    //字符串匹配的过程
    for (int i = 1, j = 0; i <= m; i++)
    {
        while (j && s[i] != q[j + 1]) //同理进行匹配
        {
            j = ne[j];
        }
        if (s[i] == q[j + 1])
        {
            j++; //如果相等就进行移动
        }
        if (j == n) //当j的长度为子串长度，那么说明这条子串完全匹配
        {
            cout << i - n << " "; //输出起始坐标，但题目中要求从0开始，但是开设坐标时我们从1开始，所以直接i-n
            j = nx[j];            // j返回到可以进行子串匹配的那个坐标
        }
    }
    return 0;
}
// KMP的实质就是找到子串中最大前缀与最大后缀